#!/usr/bin/perl
use strict;
use Getopt::Std;
use FindBin;use lib $FindBin::Bin;

my $usage = q/Usage:
 cuff_loci_stats.pl [-o <out_prefix>] \
   <cuffcmp.combined.gtf> <isoforms.fpkm_tracking> tcons.orflen [<tcons_phastCons.tab>]
   
<cuff_loci.tab> is the [filtered] output of cuffdiff_loc_check.pl
<tcons_phastCons.tab> can be generated by hg19_getcons.pl from the <cuffcmp.combined.gtf> file
/;
umask 0002;
getopts('o:') || die($usage."\n");
#my ($f_loci, $f_tracking, $f_gtf, $f_fpkm)=@ARGV;
my ($f_gtf, $f_fpkm, $f_orflen, $f_cons)=@ARGV;
die("$usage\n") unless $f_fpkm;
foreach my $f (@ARGV) {
 die("Error: file $f not found!\n") unless -f $f;
 }
my $outprefix=$Getopt::Std::opt_o || 'cuff_stats';
# --
my %samples=(
'BJAB'=>['GCB',250],
'Dogum'=>['GCB', 250],
'DOHH2'=>['GCB', 250],
'Gumbus'=>['GCB',250],
'HT'=>['GCB',250],
'Karpas422'=>['GCB',250],
'Ly1'=>['GCB',150],
'Ly18'=>['GCB',250],
'Ly19'=>['GCB',250],
'Ly2'=>['GCB',250],
'Ly4'=>['GCB',250],
'Ly7'=>['GCB',250],
'Ly8'=>['GCB',150],
'Mieu'=>['GCB',250],
'Pfieffer'=>['GCB',250],
'ULA'=>['GCB',250],
'HBL1'=>['ABC',150],  # <====== ABC from here on
'TMD8'=>['ABC',150],
'Ly10'=>['ABC',150],
'Ly3'=>['ABC',250],
'RIVA'=>['ABC',250],
'SUDHL2'=>['ABC',150],
'U2932'=>['ABC',150]
);
# ABC : ( HBL1 TMD8 Ly10 Ly3 RIVA SUDHL2 U2932 ) # 7 samples
# GCB : ( BJAB Dogum DOHH2 Gumbus HT Karpas422 Ly1 Ly18 Ly19 Ly2 Ly4 Ly7 Ly8 Mieu Pfieffer ULA ) # 16 samples
#----
# ABC merged sample: TMD8 + HBL1 + Ly3 + Ly10
# GCB merged sample: BJAB + DOHH2 + Ly1

# model samples:
my @ABCmodels=qw(HBL1 TMD8 Ly3 Ly10);
my @GCBmodels=qw(BJAB DOHH2 Dogum HT Karpas422 Ly1 Ly18 Ly19 Ly4 Ly2 Ly7 Ly8 Mieu Pfieffer ULA);
my %mABC; @mABC{@ABCmodels}=();
my %mGCB; @mGCB{@GCBmodels}=();
my %tcons; # conservation data for each transfrag (optional)
my %loc_codes; # keep track of class codes for all transfrags in a loc
my %bad_codes;
my %bad_loci; #for novel loci, if any transfrags have 'x', 's' or 'o' codes
@bad_codes{qw(x s o p)}=();
print STDERR "Loading conservation data from $f_cons..\n";
if ($f_cons) {
  open(CONS, $f_cons) || die("Error opening $f_cons!\n");
  while (<CONS>) {
    chomp;
    my @t=split(/\t/);
    next unless $t[3];
    $tcons{$t[0]}=[$t[2],$t[3]];
    }
  close(CONS);
  }
my %torf; # conservation data for each transfrag (optional)
if ($f_orflen) {
  print STDERR "Loading ORF data from $f_orflen..\n";
  open(TORF, $f_orflen) || die("Error opening $f_orflen!\n");
  while (<TORF>) {
    chomp;
    my @t=split(/\t/);
    next unless $t[1]>3;
    $torf{$t[0]}=$t[1];
    }
  close(TORF);
  }
 my %tfpkm; # tid=>[@fpkmsmp_values] values are in the same order as @fpkmsmp
 my @fpkmsmp; # array of sample names, in the same order as found in the <isoforms.fpkm_tracking> header
 my %s2idx; # sample_name => index in @fpkmsmp
 print STDERR "Loading FPKM data from $f_fpkm..\n";
 open(FPKM, $f_fpkm) || die("Error opening $f_fpkm!\n");
 my $fheader=<FPKM>;
 chomp($fheader);
 #TODO: load here all the fpkm data, with header names in fpkmsmp, and write subroutines to retrieve sums for ABC and GCB model samples
 my @colidx; #index of columns in the isoforms.fpkm_tracking file
 my $i=0;
 foreach my $fld (split(/\t/,$fheader)) {
   my $sn=$fld;
   if ($sn=~s/_FPKM$//) {
     push(@fpkmsmp, $sn);
     $s2idx{$sn}=$#fpkmsmp;
     push(@colidx, $i);
     }
  $i++;
  }
 while (<FPKM>) {
     chomp;
     my @t=split(/\t/);
     $tfpkm{$t[0]}=[@t[@colidx]];
     }
 #now to get FPKM of a transcript for a specific sample name: $tfpkm{$tid}->[$s2idx{$sample_name}]
 close(FPKM);
  
# --> model ABC vs. model GCB samples:
# allABC/HBL1.bam allABC/TMD8.bam allABC/Ly3.bam allABC/Ly10.bam
# allGCB/BJAB.bam allGCB/DOHH2.bam allGCB/Dogum.bam allGCB/HT.bam allGCB/Karpas422.bam allGCB/Ly1.bam allGCB/Ly18.bam allGCB/Ly19.bam allGCB/Ly4.bam allGCB/Ly2.bam allGCB/Ly7.bam allGCB/Ly8.bam allGCB/Mieu.bam allGCB/Pfieffer.bam allGCB/ULA.bam
#
# --> all ABC vs all GCB samples:
# allABC/HBL1.bam allABC/Ly10.bam allABC/Ly3.bam allABC/RIVA.bam allABC/SUDHL2.bam allABC/TMD8.bam allABC/U2932.bam
# allGCB/BJAB.bam allGCB/Dogum.bam allGCB/DOHH2.bam allGCB/Gumbus.bam allGCB/HT.bam allGCB/Karpas422.bam allGCB/Ly18.bam allGCB/Ly19.bam allGCB/Ly1.bam allGCB/Ly2.bam allGCB/Ly4.bam allGCB/Ly7.bam allGCB/Ly8.bam allGCB/Mieu.bam allGCB/Pfieffer.bam allGCB/ULA.bam
                     #      0       1             2        3        4       5          6            7           8           9 
my %ldat; # locus => [ ref_genes, <strand>chr, chrstart, chrstop, [@tcons], max_tlen, maxorf_len, max_numexons, cons_avg, cons_stdev, 
#                            modelABC_fpkm, modelGCB_fpkm, sample_fpkm_sums ]
#                                     10          11             12..
#
#                        0           1                  2        3       4          5         6       7          8          9           10               11          12...
#my %tdat; # tcons => [locus, <strand>chr:start-stop, ref_code, ref_id, ref_gene, [@exons], covlen, maxorf_len, cons_avg, cons_stdev, modelABC_fpkm, modelGCB_fpkm, per_sample_fpkm]
my %gffrecs;
# ---------------------  0     1       2       3           4      5      6       7        8         9         10
#           recID =>  [ chr, strand, xloc,  gene_name, tdescr, fstart, fend, [@exons], [@cds],  class_code, ref_id ]

my $gffh;
open($gffh, $f_gtf) || die("Error: failed to open $f_gtf. $!\n");
print STDERR "Loading GTF data from $f_gtf..\n";
loadGff($gffh, \%gffrecs);
#my @sorted_features=sort sortByLoc keys(%gffrecs);
print STDERR "Sorting by genomic location..\n";
my @sorted_recs=sort sortByLoc keys(%gffrecs);
print STDERR "Processing GTF records and writing transfrag stats..\n";

## transcript data:  
my $tfh;
open($tfh, ">$outprefix.t_stats.tab") || die("Error creating $outprefix.t_stats.tab!\n");
print $tfh join("\t", qw(transfrag ref_info location xlocus tlen num_exons max_ORF cons_mean cons_stdev ABC_fpkm GCB_fpkm),
   @fpkmsmp)."\n";
# - set up some loci exclusion flags:
foreach my $xloc (keys(%loc_codes)) {
  my $lcodes=$loc_codes{$xloc};
  if (index($lcodes,'j')<0 && $lcodes=~tr/xso//) {
     $bad_loci{$xloc}=1;
     #print STDERR "..declaring $xloc bad..\n";
     }
  }
my $xloc_list=[];  
processGffRecs(\%gffrecs, $tfh, \@sorted_recs, $xloc_list); #populates %ldat and writes t_stats, uses %tcons too 
close($tfh);

#now print %ldat and %tdat
print STDERR "Writing XLOCi stats..\n";
open(LOCSTATS, ">$outprefix.xloc_stats.tab") || die("Error creating $outprefix.xloc_stats.tab!\n");
#print locus table header:
print LOCSTATS join("\t", qw(xlocus ref_genes location tlist max_tlen max_exons max_ORF cons_mean cons_stdev ABC_fpkm GCB_fpkm), 
   @fpkmsmp)."\n";
#foreach my $xloc (keys(%ldat)) {
foreach my $xloc (@$xloc_list) {
  #       0       1        2       3     4       5           6          7          8         9
  my ($reflst, $schr, $cstart, $cend, $tlst, $max_tlen, $max_orf, $max_exons, $cons_avg, $cons_stdev, 
  #          10                 11            12..
          $modelABC_fpkm, $modelGCB_fpkm, @sample_fpkms)=@{$ldat{$xloc}};
  print LOCSTATS join("\t", $xloc, ((@$reflst>0) ? join(',',@$reflst) : '-'), $schr.":$cstart-$cend", join(',', @$tlst), 
        $max_tlen, $max_exons, $max_orf, sprintf('%.5f', $cons_avg), sprintf('%.5f', $cons_stdev), 
        sprintf0($modelABC_fpkm), sprintf0($modelGCB_fpkm), (map { sprintf0($_) } @sample_fpkms) )."\n";
  }
close(LOCSTATS);

## transcript data:  
#open(TSTATS, ">$outprefix.t_stats.tab") || die("Error creating $outprefix.t_stats.tab!\n");
#print TSTATS join("\t", qw(xloc refcode:refId|refGene location exons len num_exons cons_mean const_stdev ABC_fpkm GCB_fpkm),
#   @fpkmsmp)."\n";
#foreach my $t (keys(%tdat)) {
#  #      0     1         2         3          4         5       6          7          8         9                10            11
#  my ($xloc, $chrloc, $ref_code, $ref_id, $ref_gene, $exonlst, $covlen, $maxorf_len, $cons_avg, $cons_stdev, $modelABC_fpkm, $modelGCB_fpkm,
#          @sample_fpkms)=@{$tdat{$t}};
#  print TSTATS join("\t", $t, "$ref_code:$ref_id|$ref_gene", $chrloc, join(',', (map { $_->[0].'-'.$_->[1] } @$exonlst)), $covlen, $maxorf_len, scalar(@$exonlst),
#          $cons_avg, $cons_stdev, $modelABC_fpkm, $modelGCB_fpkm, @sample_fpkms)."\n";
#  }
#close(TSTATS);

print STDERR "Done.\n";

# --
#if ($outfile) {
# select(STDOUT);
# close(OUTF);
# }

#************ Subroutines **************

sub sprintf0 {
 return ($_[0]==0.0) ? '0' : sprintf('%.5f',$_[0]);
}

sub loadGff {
 my ($fh, $recs)=@_; # $hr=\%gffrecs 
 # ---------------------  0     1       2       3           4      5       6       7        8        9          10
 #           recID =>  [ chr, strand, xloc,  gene_name, tdescr, fstart, fend, [@exons], [@cds],  class_code, nearest_ref_id ]
 while (<$fh>) {
   next if m/^\s*#/;
   chomp;
   my ($chr, $track, $f, $fstart, $fend, $fscore, $strand, $frame, $lnum)=split(/\t/);
   next unless $fstart>1 && $lnum;
   next if $f eq 'gene' || $f eq 'locus'; # Warning: skipping any 'gene' or 'locus' features, unconditionally
   my ($gname, $tdescr, $xloc, $classcode, $refid);
   if ($lnum=~m/nearest_ref[= ]+"?([^;"]+)/) {
      $refid=$1;
      }
   if ($lnum=~m/class_code[\.= ]+"?([\w=])/) {
      $classcode=$1;
      }
   my $gff3_ID;
   my $gff3_Parent;
   ($fstart, $fend)=($fend, $fstart) if $fend<$fstart;
   ($gff3_ID)=($lnum=~m/\bID=([^;]+)/);
   ($gff3_Parent)=($lnum=~m/\bParent=([^;]+)/);
   if ($gff3_ID || $gff3_Parent) { # GFF format
      $gff3_ID=~tr/"//d; #"
      $gff3_Parent=~tr/"//d; #"
      $gff3_Parent='' if ($f eq 'mRNA');
      if ($gff3_ID && !$gff3_Parent) { #top level feature
         if ($f=~m/RNA/i || $f=~/gene/) {
           # try to parse the description, if any
           if ($lnum=~m/\b(?:descr|tophit|info|product)\s*=\s*"?([^;"]+)/i) {
             $tdescr=$1;
             }
            #elsif ($lnum=~m/Name[= ]\s*"?([^;"]+)/) {
            # $tdescr=$1;
            # }
           if ($lnum=~m/\bgene_name[ =]+"?([^;"]+)/i) {
             $gname=$1;
             }
            elsif ($lnum=~m/Name[= ]+"?([^;"]+)/) {
             $gname=$1;
             }
           if ($lnum=~m/locus="?([^;"]+)/i || $lnum=~m/loc="?([^;"]+)/i) {
             $xloc=$1;
             }
           $tdescr='' if ($tdescr eq $gname);
           $gname='' if $gname eq $gff3_ID;
           }
         die("Error: duplicate feature $gff3_ID on $chr\n") if (exists($$recs{"$chr|$gff3_ID"}));
         #my $recID="$chr|$gff3_ID";
         my $recID=$gff3_ID;
         $gname=$refid if $refid;
         $$recs{$recID} = [$chr, $strand, $xloc, $gname, $tdescr, $fstart, $fend, [], [], $classcode, $refid ];
         $loc_codes{$xloc}.=$classcode if $classcode;
         next;
         } # parent/top-level feature
      } #GFF
     else { #GTF format
      next if ($f eq 'transcript'); #exception: GTF with parent 'transcript' feature
      }
   # -------------- exon/CDS line here:
   my $recID;
   if ($track=~/^jigsaw/ && $lnum=~m/^\d+$/) {
     $recID=$chr.'.jsm.'.$lnum;
     }
    elsif ($lnum=~m/Parent="?(['\:\w\|\-\.]+)/) {
     $recID=$1;
     }
    elsif ($lnum=~m/transcript_id[= ]+"?(['\:\w\.\|\-]+)/) {
     $recID=$1;
     }
    else {
     die("Error: cannot parse locus/transcript name from input line:\n$_\n");
     }
   if ($lnum=~m/gene_id[= ]+"?(['\:\w\.\|\-]+)/) {
      $xloc=$1; # cuffcompare writes XLOC as gene_id
      }
   if ($lnum=~m/\bgene_name[ =]+"?([^;"]+)/i) {
             $gname=$1;
             }
   $tdescr='' if index($recID, $tdescr)>=0;
   $gname='' if index($recID, $gname)>=0;
   #$recID=$chr.'|'.$recID;
   my $ld = $$recs{$recID};
   if ($ld) { #existing entry
     my $i=($f eq 'CDS') ? 8 : 7;
     my ($lstart, $lend)=($$ld[5], $$ld[6]);
     $$ld[5]=$fstart if $fstart<$lstart;
     $$ld[6]=$fend if $fend>$lend;
     push(@{$$ld[$i]}, [$fstart, $fend, $fscore]);
     }
    else { # first time seeing this locus/gene
     $$recs{$recID} = ($f eq 'CDS') ? 
           [$chr, $strand, $xloc, $gname, $tdescr, $fstart, $fend, [], [[$fstart, $fend, $fscore]], $classcode, $refid ] :
           [$chr, $strand, $xloc, $gname, $tdescr, $fstart, $fend, [[$fstart, $fend, $fscore]], [], $classcode, $refid ] ;
           # 0       1      2        3       4        5       6         7 (exons)            8 (CDS)  9           10  
     $loc_codes{$xloc}.=$classcode if $classcode;
     }
 } #while <$fh>
} # loadGff

sub sortByLoc {
 my $da=$gffrecs{$a};
 my $db=$gffrecs{$b};
 if ($$da[0] eq $$db[0]) {
    return ($$da[5]==$$db[5]) ? $$da[6] <=> $$db[6] : $$da[5] <=> $$db[5] ;
    }
  else { return $$da[0] cmp $$db[0] ; }
}

sub processGffRecs {
 #return if keys(%recs)==0;
 my ($recs, $tstats, $rlist, $loclist)=@_;
 my @recs_keys;
 my %lseen; #seen xloci
 unless ($rlist) {
    @recs_keys=keys(%$recs);
    $rlist=\@recs_keys;
    }
 foreach my $gffid (@$rlist) {
    my $gffdata=$$recs{$gffid};
   # my $ld=$recs{$l} || die ("Error: locus $l found in list but not in hash!\n");
   #     0       1       2      3       4      5         6    7    8        9        10
   my ($chr, $strand, $xloc, $gname, $descr, $lstart, $lend, $er, $cr, $classcode, $refid) = @$gffdata;
   # my ($mstart,$mend)=($lstart, $lend);
   next if exists($bad_codes{$classcode}) || exists($bad_loci{$xloc});
   my $CDexons=0;
   my @ex;
   my @cds;
   #some records might lack exons, but have only CDS segments (e.g. mitochondrial genes)
   if (@$er<1 && @$cr>0) {
     @ex = sort { $a->[0] <=> $b->[0] } @$cr;
     $CDexons=1;
     }
    else {
     @ex = sort { $a->[0] <=> $b->[0] } @$er;
     }
   # --------------
   # get the more accurate version of the start-end coords for the feature
   my $covlen=0;
   map { $covlen+=$_->[1]-$_->[0]+1 } @ex;
   my ($mstart, $mend) = ($ex[0]->[0], $ex[-1]->[1]);
   my ($cavg, $cstd)=('-','-');
   my $cd=$tcons{$gffid};
   ($cavg, $cstd)=@$cd if ($cd);
   my $orfmax=$torf{$gffid} || '0';
   my $numexons=scalar(@ex);
   my ($ABC_fpkm, $GCB_fpkm)=(0,0);
   map {  $ABC_fpkm+=$tfpkm{$gffid}->[$s2idx{$_}]  } @ABCmodels;
   map {  $GCB_fpkm+=$tfpkm{$gffid}->[$s2idx{$_}]  } @GCBmodels;
   if ($GCB_fpkm == 0.0 && $ABC_fpkm == 0.0) {
     print STDERR "Warning: transfrag $gffid has 0 FPKM in all ABC and GCB model samples!\n";
     next;
     }
   #$tdat{$gffid}=[$xloc, $strand.$chr.":$mstart-$mend", $classcode, $refid, $gname, [@ex], $covlen, $orfmax, $cavg, $cstd, $ABC_fpkm, $GCB_fpkm, @{$tfpkm{$gffid}}];
   #                 0             1                        2            3       4     5       6       7        8      9       10         11         12..
   my $refstatus = $refid ? "$classcode:$refid|$gname" : '-';
   
   print $tstats join("\t", $gffid, $refstatus, $strand.$chr.":$mstart-$mend", 
          $xloc, $covlen, scalar(@ex), $orfmax, 
          sprintf('%.5f',$cavg), sprintf('%.5f',$cstd), sprintf0($ABC_fpkm), 
          sprintf0($GCB_fpkm), (map { sprintf0($_) } @{$tfpkm{$gffid}}) )."\n";

   #my $td=$tdat{$gffid};
   unless (exists($lseen{$xloc})) {
     $lseen{$xloc}=1;
     push(@$loclist, $xloc);
     }
   my $ld=$ldat{$xloc};
   if ($ld) { #update existing $ldat
     #$$ld[0].=$classcode;
     push(@{$$ld[0]},"$refid|$gname") if ($classcode eq 'j');
     push(@{$$ld[4]}, $gffid);
     $$ld[2]=$mstart if $mstart<$$ld[2];
     $$ld[3]=$mend if $mend>$$ld[3];
     $$ld[5]=$covlen if $covlen>$$ld[5];
     $$ld[6]=$orfmax if int($orfmax)>$$ld[6];
     $$ld[7]=$numexons if $numexons>$$ld[7];
     $$ld[8]+=$cavg; $$ld[8]/=2;
     $$ld[9]+=$cstd; $$ld[9]/=2;
     $$ld[10]+=$ABC_fpkm;
     $$ld[11]+=$GCB_fpkm;
     for (my $i=0;$i<@fpkmsmp; $i++) {
          #$$ld[10+$i]+=$$td[10+$i];
          $$ld[12+$i]+=$tfpkm{$gffid}->[$i];
          }
     }
    else { #new xloc
     #             0                 1          2       3       4       5         6        7         8     9        10         11          12 ..
     $ldat{$xloc}=[[], $strand.$chr, $mstart, $mend, [$gffid], $covlen, $orfmax, $numexons, $cavg, $cstd, $ABC_fpkm, $GCB_fpkm, @{$tfpkm{$gffid}}];
     }
   #my @exonlst = map { $_->[0].'-'.$_->[1] } @ex;
   #my ($avg, $std)=fetchCons($chr, \@ex);
   #substr($gffid, 0, length($chr)+1)='';
   #print join("\t", $gffid, $chr.$strand.':'.join(',',@exonlst),$avg, $std)."\n";
  } #for each stored transcript
}
