#!/usr/bin/perl
use strict;
use Getopt::Std;
#use FindBin;use lib $FindBin::Bin;

my $usage = q/Usage:
 btabflt.pl [-p <min_sim>] [-c <min_cov>] [-i <max_intron>] <input_btab..>
 
 It assumes that the input has the extended format which includes
 segment information (i.e. as generated by blast2btab)
 
 It will show only those alignments of at least <min_sim> percent similarity
 (default: 60), at least <min_cov> percent coverage of query (default 50)
 and not having a genomic gap (intron) larger than <max_intron> 
 (default: 500000)
 
/;

getopts('p:c:i:') || die ($usage."\n");
my $mincov=$Getopt::Std::opt_c || 50;
my $minpsim=$Getopt::Std::opt_p || 70;
my $maxintron=$Getopt::Std::opt_i || 500000;

while (<>) {
 next if m/^\s*#/;
 my $line=$_;
 chomp;
 #       0      1      2       3     4     5       6    7     8      9
 my ($qname, $date, $qlen, $method, $db, $sname, $q_5, $q_3, $s_5, $s_3,
 #    10    11     12      13      14    15        16       17       18
    $pid, $psim, $score, $fofsb, $fofse, $sdescr, $frame, $strand, $slen, 
 #    19    20      21
    $e_val, $scov, $hsps)=split(/\t/);
 next unless $psim>=$minpsim;
 my @hsp=split(/\~/,$hsps);
 my @qh; #current line HSPs on query: list of [ql, qr]
 my @sh; #current line HSPS on subj
 foreach my $h (@hsp) {
     my ($q5,$q3, $h5, $h3, $p)=($h=~/(\d+)\-(\d+)\:(\d+)\-(\d+)\|([\d\.]+)/);
     die("Error parsing segment data $h for btab line:\n$_\n") unless $p>1;
     ($q5, $q3)=($q3,$q5) if $q5>$q3;
     push(@qh, [$q5, $q3]);
     ($h5, $h3)=($h3,$h5) if $h5>$h3;
     push(@sh, [$h5, $h3]);
     }
 @sh = sort { $main::a->[0] <=> $main::b->[0] } @sh;
 my $prev_end=0;
 my $badintron=0;
 foreach my $ed (@sh) {
     if ($prev_end) {
         if ($$ed[0]-$prev_end>$maxintron) {
           $badintron=1;
           last; 
           }
         } 
    $prev_end=$$ed[1];
    }
 next if $badintron;
 my $cov=getCov($qlen, \@qh);
 next unless $cov>=$mincov;
 chomp($line);
 print $line."\t$cov\n";
}

sub getCov { 
 # merge overlapping segments (yes, blast can produce such segments)
 my ($len, $r)=@_;
 my @a=sort { $main::a->[0]<=>$main::b->[0] } @$r;
 my $wasovl=1;
 my @m = map { [$_->[0], $_->[1]] } @a;
 WASOVL: while ($wasovl) {
  $wasovl=0;
  for (my $i=0;$i<@m-1;$i++) {
     for (my $j=$i+1;$j<@m;$j++) {
      next if $i==$j;
      my ($l1, $r1)=($m[$i]->[0], $m[$i]->[1]);
      my ($l2, $r2)=($m[$j]->[0], $m[$j]->[1]);
      #we know that l2>=l1 for sure
      if ($l2<=$r1) {
        #intersection detected;
        $wasovl=1;
        $m[$i]->[1] = ($r1>$r2)?$r1:$r2; #max right coord
        splice(@m, $j);
        next WASOVL;
        } #intersection
     } #j
   } #i
 }#while wasovl
 my $cov=0;
 map { $cov+=$_->[1]-$_->[0]+1 } @m;
 return sprintf('%d',($cov*100.00)/$len);
}
